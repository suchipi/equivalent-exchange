import traverse from "@babel/traverse";
import * as babelParser from "@babel/parser";
import * as types from "./types-ns";
import * as recast from "recast";

export {
  /** Re-export of @babel/traverse's default export. */
  traverse,
  /** Contains the named exports of both @babel/types and @babel/traverse. */
  types,
};

/**
 * The node type that `transmute` will give to you as the root AST node.
 *
 * It's an alias to babel's `File` node type.
 */
export type AST = types.File;

/**
 * Options that affect the behavior of `transmute`, `codeToAst`, and `astToCode`.
 */
export type TransmuteOptions = {
  /**
   * The name of the file whose code you are transmuting.
   *
   * If passed, parse errors thrown by `transmute` will be clearer,
   * and it will be possible to generate sourcemaps for the file.
   */
  fileName?: string;

  /**
   * The name of the output file where you will store a sourcemap
   * generated by transmute.
   *
   * Both `fileName` and `sourceMapFileName` must be present to
   * generate a sourcemap.
   */
  sourceMapFileName?: string;

  /**
   * An input sourcemap to compose the newly-generated sourcemap
   * with.
   */
  inputSourceMap?: any;

  /**
   * Options that control how `transmute` will convert code strings into ASTs.
   */
  parseOptions?: {
    /**
     * Which type-checker syntax to use.
     *
     * Defaults to "typescript".
     */
    typeSyntax?: "typescript" | "flow";

    /**
     * Which decorator proposal syntax to use.
     *
     * Defaults to "legacy".
     */
    decoratorSyntax?: "new" | "legacy";

    /**
     * Which syntax proposal to use for the pipeline operator.
     *
     * Defaults to "hack".
     */
    pipelineSyntax?: "minimal" | "fsharp" | "hack" | "smart";

    /**
     * Which topic token to use when using the "hack" syntax proposal for the pipeline operator.
     *
     * Defaults to "%". Only used when pipelineSyntax is "hack".
     */
    hackPipelineTopicToken?: "^^" | "@@" | "^" | "%" | "#";
  };
};

/**
 * The result of transmuting some code. If the options you passed into
 * `transmute` had sourcemap-related stuff set, then the `map` property
 * will be set. Otherwise, it'll be null.
 */
export type TransmuteResult = {
  /**
   * The transformed code string.
   */
  code: string;

  /**
   * A source map describing the changes between the original code string and
   * its transformed version.
   */
  map?: any;
};

/**
 * The interface of the `transmute` function, which has 4 different call signatures.
 */
export interface Transmute {
  /**
   * Parses `code` into an AST, then passes that to `transform`, which
   * is expected to mutate the AST somehow.
   *
   * Once the Promise returned by `transform` has resolved, it converts
   * the AST back into a string, and returns you a `TransmuteResult`,
   * which has the transformed string on it as its `code` property.
   */
  (
    code: string,
    transform: (ast: AST) => Promise<void>
  ): Promise<TransmuteResult>;

  /**
   * Parses `code` into an AST, then passes that to `transform`, which
   * is expected to mutate the AST somehow.
   *
   * Once the Promise returned by `transform` has resolved, it converts
   * the AST back into a string, and returns you a `TransmuteResult`,
   * which has the transformed string on it as its `code` property.
   *
   * The contents of `options` will determine what syntax options to use
   * to parse the code, and whether to consume/generate source maps.
   * See the definition for `TransmuteOptions` for more details.
   */
  (
    code: string,
    options: TransmuteOptions,
    transform: (ast: AST) => Promise<void>
  ): Promise<TransmuteResult>;

  /**
   * Parses `code` into an AST, then passes that to `transform`, which
   * is expected to mutate the AST somehow.
   *
   * Then, it converts the AST back into a string, and returns you a
   * `TransmuteResult`, which has the transformed string on it as its
   * `code` property.
   */
  (code: string, transform: (ast: AST) => void): TransmuteResult;

  /**
   * Parses `code` into an AST, then passes that to `transform`, which
   * is expected to mutate the AST somehow.
   *
   * Then, it converts the AST back into a string, and returns you a
   * `TransmuteResult`, which has the transformed string on it as its
   * `code` property.
   *
   * The contents of `options` will determine what syntax options to use
   * to parse the code, and whether to consume/generate source maps.
   * See the definition for `TransmuteOptions` for more details.
   */
  (
    code: string,
    options: TransmuteOptions,
    transform: (ast: AST) => void
  ): TransmuteResult;
}

/**
 * Parses a JavaScript/TypeScript code string into an AST.
 *
 * This function is used internally by `transmute`.
 *
 * The options parameter works the same as the options parameter for `transmute`.
 */
export function codeToAst(code: string, options: TransmuteOptions = {}): AST {
  const typeSyntax = options?.parseOptions?.typeSyntax || "typescript";
  const decoratorSyntax = options?.parseOptions?.decoratorSyntax || "legacy";
  const pipelineSyntax = options?.parseOptions?.pipelineSyntax || "hack";
  const hackPipelineTopicToken =
    options?.parseOptions?.hackPipelineTopicToken || "%";

  const ast: AST = recast.parse(code, {
    sourceFileName: options.fileName,
    inputSourceMap: options.inputSourceMap,
    parser: {
      parse(source: string) {
        return babelParser.parse(source, {
          sourceFilename: options.fileName,
          allowAwaitOutsideFunction: true,
          allowImportExportEverywhere: true,
          allowReturnOutsideFunction: true,
          allowSuperOutsideMethod: true,
          allowUndeclaredExports: true,
          tokens: true,
          plugins: [
            ...(typeSyntax === "flow"
              ? (["flow", "flowComments"] as const)
              : (["typescript"] as const)),

            "jsx",

            "asyncDoExpressions",
            "asyncGenerators",
            "bigInt",
            "classPrivateMethods",
            "classPrivateProperties",
            "classProperties",
            "classStaticBlock",
            "decimal",

            decoratorSyntax === "new" ? "decorators" : "decorators-legacy",

            "doExpressions",
            "dynamicImport",
            "exportDefaultFrom",
            "exportNamespaceFrom",
            "functionBind",
            "functionSent",
            "importAssertions",
            "importMeta",
            "logicalAssignment",
            "moduleBlocks",
            "moduleStringNames",
            "nullishCoalescingOperator",
            "numericSeparator",
            "objectRestSpread",
            "optionalCatchBinding",
            "optionalChaining",
            "partialApplication",
            "privateIn",
            "throwExpressions",
            "topLevelAwait",

            [
              "pipelineOperator",
              {
                proposal: pipelineSyntax,
                ...(pipelineSyntax === "hack"
                  ? {
                      // Babel's type disallows "^", but babel's runtime
                      // seems to allow it, so ignore this error.
                      topicToken: hackPipelineTopicToken as any,
                    }
                  : {}),
              },
            ],
          ],
        });
      },
    },
  });

  return ast;
}

/**
 * Converts an AST back into a code string.
 *
 * This function is used internally by `transmute`.
 *
 * The options parameter works the same as the options parameter for `transmute`.
 */
export function astToCode(
  ast: AST,
  options: TransmuteOptions = {}
): TransmuteResult {
  const recastResult = recast.print(ast, {
    sourceMapName: options.sourceMapFileName || "sourcemap.json",
  });
  return {
    code: recastResult.code,
    map:
      options.fileName && options.sourceMapFileName ? recastResult.map : null,
  };
}

type Clonable =
  | {}
  | number
  | string
  | null
  | undefined
  | boolean
  | Array<Clonable>;

export function clone<T extends Clonable>(input: T): T {
  if (Array.isArray(input)) {
    const copy = new Array(input.length);
    for (let i = 0; i < input.length; i++) {
      copy[i] = input[i];
    }
    // @ts-ignore could be instantiated with different subtype
    return copy;
  }

  if (typeof input !== "object" || input == null) {
    return input;
  }

  const copy = Object.create(Object.getPrototypeOf(input));
  for (const key of Object.keys(input)) {
    copy[key] = clone(input[key]);
  }

  // @ts-ignore could be instantiated with different subtype
  return copy;
}

// @ts-ignore typescript overload refinement leaves a lot to be desired
export const transmute: Transmute = (
  ...args: Array<any>
): TransmuteResult | Promise<TransmuteResult> => {
  const code: string = args[0];
  let options: TransmuteOptions = {};
  let transform: (ast: AST) => void | Promise<void>;
  if (typeof args[1] === "function") {
    transform = args[1];
  } else {
    options = args[1];
    transform = args[2];
  }

  const ast = codeToAst(code, options);

  const result = transform(ast);
  if (
    typeof result === "object" &&
    result != null &&
    typeof result.then === "function"
  ) {
    return result.then(() => {
      return astToCode(ast, options);
    });
  } else {
    return astToCode(ast, options);
  }
};
